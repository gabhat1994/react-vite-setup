
// This a service worker file for receiving push notifitications.
// See 'Access registration token section' @ https://firebase.google.com/docs/cloud-messaging/js/client#retrieve-the-current-registration-token

// This listener has to be defined BEFORE importing Firebase modules,
// otherwise Firebase will override it.
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const urlToOpen = new URL('/', self.location.origin).href;

  const promiseChain = clients
    .matchAll({
      type: 'window',
      includeUncontrolled: true,
    })
    .then((windowClients) => {
      const windowsToFocus = windowClients.filter(
        (windowClient) => !!windowClient.url,
      );
      if (windowsToFocus.length > 0) {
        windowsToFocus.forEach((w) => {
          w.focus();
        });
      } else {
        clients.openWindow(urlToOpen).then((windowClient) => {
          return windowClient ? windowClient.focus() : null;
        });
      }
    });

  event.waitUntil(promiseChain);
});



// Scripts for firebase and firebase messaging
importScripts(
  'https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js',
);
importScripts(
  'https://www.gstatic.com/firebasejs/9.0.0/firebase-messaging-compat.js',
);

// Initialize the Firebase app in the service worker by passing the generated config
const firebaseConfig = {
  apiKey: 'AIzaSyDtLonRFbNNQJn647DEOhbuCr_q4QVZnRc',
  authDomain: 'noumena-dev-a32b9.firebaseapp.com',
  projectId: 'noumena-dev-a32b9',
  storageBucket: 'noumena-dev-a32b9.appspot.com',
  messagingSenderId: '596937929096',
  appId: '1:596937929096:web:02c926cc440bb523738a3d',
  measurementId: 'G-TXW3T588BF',
};

firebase.initializeApp(firebaseConfig);

// Retrieve firebase messaging
const messaging = firebase.messaging();

// Handle incoming messages while the app is not in focus (i.e in the background, hidden behind other tabs, or completely closed).
messaging.onBackgroundMessage((payload) => {
  console.debug('[firebase-messaging-sw] Received background message', payload);

  if (!isValidNotification(payload)) {
    console.debug('Invalid notification payload, skipping...');
    return;
  }

  // TODO: Remove once BE is deployed to PROD and no longer sends 'notification' at root level.
  if (isHandledByFirebase(payload)) {
    const data = getData(payload);
    const notificationData = getFirebaseNotificationData(payload);

    return hideFirebaseNotification(notificationData)
      .then(() => {
        showCustomNotification(notificationData);
      }).then(() => {
        passDataToClient(notificationData, data);
      });
  }

  const data = getData(payload);
  const notificationData = getNotificationData(payload);

  return showCustomNotification(notificationData)
    .then(() => {
      passDataToClient(notificationData, data);
    });
});

// TODO: Remove once BE is deployed to PROD and no longer sends 'notification' at root level.
function hideFirebaseNotification(notificationData) {
  if (!notificationData) {
    return Promise.resolve();
  }

  // This often doesn't work, so see below for a workaround.
  if ('hideNotification' in self.registration) {
    self.registration.hideNotification();
  }

  // Hide notifications generated by Firebase, so we can display our custom.
  return self.registration.getNotifications()
    .then((notifications) => {
      notifications.forEach((notification) => {
        // Auto-generated notifications from Firebase don't have any tag set,
        // while our custom ones do have it, so it's easy to filter out redundant notifications.
        if (notification.tag === '') {
          notification.close();
        }
      });
    });
}

function showCustomNotification(notificationData) {
  if (!notificationData.title) {
    return Promise.resolve();
  }

  const notificationTitle = notificationData.title;
  const notificationOptions = {
    icon: '/images/pwa_logo_512.png',
    ...notificationData,
  };

  return self.registration.showNotification(
    notificationTitle,
    notificationOptions,
  );
}

function passDataToClient(notificationData, data) {
  return self.clients
    .matchAll({
      type: 'window',
      includeUncontrolled: true,
    })
    .then((windowClients) => {
      windowClients.map((client) => {
        if (!client.focused) {
          client.postMessage({
            data: { ...data, __isBackgroundMessage: true },
            notification: notificationData
          });
        }
      });
    });
}

function getFirebaseNotificationData(payload) {
  return ('notification' in payload) && payload.notification 
    ? payload.notification
    : null;
}

function getNotificationData(payload) {
  const data = getData(payload);
  if (data && 'notification' in data) {
    // Firebase stringifies nested objects, we need to parse them.
    return typeof data.notification === 'string' 
      ? JSON.parse(data.notification || 'null') 
      : data.notification || null;
  }

  return null;
}

function getData(payload) {
  return payload.data || null;
}

function isHandledByFirebase(payload) {
  return 'notification' in payload;
}

function isValidNotification(payload) {
  const hasData = !!getData(payload);
  const hasNotificationData = !!(isHandledByFirebase(payload) ? getFirebaseNotificationData(payload) : getNotificationData(payload));

  return hasData && hasNotificationData;
}

